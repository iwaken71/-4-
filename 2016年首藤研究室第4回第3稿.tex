\documentclass{jarticle}
\title{2016年度 首藤研究室 輪講 第4回}
\author{青木　優介}
\date{2016年4月13日}
\usepackage[top=10truemm,bottom=10truemm,left=10truemm,right=10truemm]{geometry}
\usepackage{fancyhdr}
\usepackage{comment}

\renewcommand{\arraystretch}{1.2} % 表の行の高さ
\setlength\intextsep{2pt} % 表と本文の間の距離
\setcounter{secnumdepth}{4}%節番号を表示する深さ

\pagestyle{plain}
\setlength{\footskip}{0cm}

\makeatletter % start

% jarticle.cls にあったものを改変
\renewcommand{\section}{\@startsection{section}{1}{\z@}%
   {.3\Cvs \@plus.5\Cvs \@minus.2\Cvs}%
   {.1\Cvs \@plus.3\Cvs}%
   {\reset@font\Large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{\z@}%
   {.3\Cvs \@plus.5\Cvs \@minus.2\Cvs}%
   {.1\Cvs \@plus.3\Cvs}%
   {\reset@font\large\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{\z@}%
   {.3\Cvs \@plus.5\Cvs \@minus.2\Cvs}%
   {.1\Cvs \@plus.3\Cvs}%
   {\reset@font\normalsize\bfseries}}

% http://yoppi.hatenablog.com/entry/20091229/1262088390 にあったものを改変
\newcommand{\subsubsubsection}{\@startsection{paragraph}{4}{\z@}%
   {.0\Cvs \@plus.5\Cdp \@minus.2\Cdp}%
   {.1\Cvs \@plus.3\Cdp}%
   {\reset@font\sffamily\normalsize}}

\makeatother % end

\begin{document}

\renewcommand{\baselinestretch}{1.5} % 行間

\maketitle

\begin{abstract}
\begin{small}
この章では，ファイルの記述や内容に基づくクエリを支持する方法を紹介する.ファイルの記述に基づくクエリを支持する方法は，\textbf{多次元インデックスベース手法} (\textit{multi-dimensional index based approach})と\textbf{複数属性インデックスベース手法} (\textit{multi-attribute index based approach})の2種類が存在し，前者を採用するシステムの例として\textbf{VBI-Tree}と\textbf{SSP}，後者を採用するシステムの例として\textbf{Mercury}を解説する．ファイルの内容に基づくクエリを支持する方法は3種類存在する．\textbf{マッピングベース手法} (\textit{mapping-based approach})を採用するシステムの例として\textbf{CISS}と\textbf{ZNet}，
\textbf{距離ベース手法} (\textit{distance-based approach})の例として\textbf{M-Chord}と\textbf{SIMPEER}，\textbf{ハッシングベース手法} (\textit{hashing-based approach})の例として\textbf{LSH Forest}を解説する．
\end{small}
\end{abstract}

{\small

\setcounter{section}{4} 
\setcounter{subsection}{0}

\subsection{多次元データ共有}
既存の多くのファイル共有P2Pシステムは，ファイルタイトルによるクエリは支持しているが，ファイルの記述によるクエリも支持することが望ましい．ファイル共有アプリケーションでは，よく\textbf{属性} (\textit{attribute})によってファイルの記述が表現される．この属性に基づくクエリを支持する方法は以下の2通りがある．
\begin{itemize}
	\item\textbf{多次元インデックスベース手法} (\textit{multi-dimensional index based approach}): 多次元インデックスベース手法では，各属性を多次元空間の次元とし，クエリは多次元空間内を進む．CANは多次元インデックスを最初に支持したP2Pシステムである．CANは\textbf{kd-Tree}に類似する構造のため，直接多次元データを配置することができる．CAN以降のシステムも，多次元インデックスを支持するために\textbf{R-Tree}， \textbf{X-Tree}，\textbf{M-Tree}などの伝統的な多次元インデックス木構造を採用している．\textbf{VBI-Tree}は，これらとは異なる木構造を採用しているフレームワークである．

	\item\textbf{複数属性インデックスベース手法} (\textit{multi-attribute index based approach}): 複数属性インデックスベース手法では，属性ごとにインデックスを保持し，クエリはインデックスごとに進む．複数属性インデックス手法の例を2つ紹介する。一つは\textbf{MAAN} (\textit{Multi-Attribute Addressable Network})である．MAANは全ての属性を一つのChordリングに索引付けることで，複数属性インデックスを支持する．クエリは\textbf{優位属性} (\textit{dominate attribute})に基づいて進み，他の属性はフィルターとして使われる．一方で\textbf{Mercury}では，各属性を\textbf{ルーティングハブ} (\textit{routing hub})と呼ばれる，分割されたChordリングに索引付ける．アイテムは全てのルーティングハブに送られる必要がある．
\end{itemize}

データ検索の質を向上させるためには、他のユーザの評価に基づくべきである．そのような特徴は，ソーシャルネットワークやコミュニティベースシステムで一般的である．ファイル内容を記述する追加の情報の例としては，ユーザによる種々の側面の評価がある．その場合，ユーザは他に優位なファイルがないようなファイルを検索することに関心がある．\textbf{スカイラインクエリ} (\textit{skyline query})とは，自身より全ての属性で優れているファイルが存在しないようなファイルを探索するクエリである．\textbf{SkyPeer}はスカイラインクエリを支持するために，効率的に返答を得ることが可能な部分空間スカイラインクエリを利用する．SkyPeerはピア内のスカイラインクエリの計算を最適化し，不必要なテータ転送の量を減らすため，\textbf{閾値ベースアルゴリズム} (\textit{threshold based algorithm})を使用している．\textbf{DSL} (\textit{Distributed Skyline Query})は並列にスカイラインの探索を行うが，ノードは計算を開始するために，直前のノードの計算が完了するのを待つ必要があり，応答時間が遅くなる．また，必要のない部分空間スカイラインの結果が送信されることでのオーバヘッドも起こる．\textbf{SSP} (\textit{Skyline Space Partitioning})は，最初にノード内のスカイラインクエリの結果が必ず最終的なスカイラインに含まれることを保証したノードを探索することで，これらの問題を解決している．


\subsubsection{VBI-Tree}
VBI-Treeは，二分木構造に基づいた多次元インデックスを採用したフレームワークである．各ピアは\textbf{間順走査} (\textit{in-order traversal})で隣り合っている葉ノードと内部ノードの組を管理する．葉ノードは，特定の多次元領域に属するデータのインデックスを保持するノードである．内部ノードは，その子ノードが管理する領域全体を覆う領域のルーティングを管理するノードである．内部ノードは，以下の5種類のリンクを保持する．
\begin{itemize}
  \item\textbf{親リンク} (\textit{parent link}): 内部ノードの親ノードへのリンクを示す．
  \item\textbf{子リンク} (\textit{child link}): 内部ノードの子ノードへのリンクを示す．
  \item\textbf{近接リンク} (\textit{adjacent link}): 間順走査で隣り合うノードへのリンクを示す．
  \item\textbf{隣接リンク} (\textit{neighbor link}): 同じレベルで左右に$2^i$離れたノードへのリンクを示す．
  \item\textbf{上方リンク} (\textit{upside link}): 内部ノードの先祖ノードへのリンクを示す．
\end{itemize}
これらのリンクはリンク先へのポインタだけでなく，リンク先のノードが担当する多次元領域の情報も保持する．ノード$n$がクエリを発行又は受信すると，クエリの範囲が自身の内部ノードの担当領域に含まれるか検査する．含まれるとき，クエリの範囲を担当する子リンクにクエリを転送する．加えて，クエリの範囲を完全に覆う担当範囲を持つもっとも近い祖先のノード$a$を探索する．$a$が存在するとき，$n$から$a$までのパス上の各祖先$a'$について，$n$と反対側の$n$の隣接ノードにクエリを送信する．この方法により，根付近でのボトルネックを作らずに，クエリの範囲を含んでいる担当範囲をもつ全てのノードにクエリを送信することが可能である．

VBI-Treeは，探索のパスを保持することでクエリのループを避け，また，祖先のノードの担当領域の変化に応じた上方リンクの修正が生じることを避けている．VBI-Treeは，\textbf{離散型データ} (\textit{discrete data})という新しい概念を支持している．離散型データとは，内部ノードに保持された，担当領域に該当しないデータのことである．離散型データは上方リンクの修正コストを下げるために導入されたが，データが多く挿入，離脱される動的な環境では，なおコストは高い．また，ボトムアップの探索は，高レベルのノードでのボトルネックを避けるが，探索範囲が高レベルのノードの担当する領域を横切るとき，多くの葉ノードを探索する必要がある．



\subsubsection{\textbf{Mercury}}
\textbf{Mercury}は複数属性インデックスを支持するために，各属性のインデックスを担当する\textbf{ハブ}にノードを分配する．各ノードは一つ以上のハブに参加する．ハブ内のノードは円形に配置され，\textbf{ハーモニック確率密度関数} (\textit{harmonic probability distribution function})を使用した経路表に基づく近隣リンクを持つ．さらに，ハブ間でのルーティングのために，各ノードは他のハブ内のノードへのリンクを持つ．

アイテムがネットワークに挿入されるとき，各属性について対応するハブに属性値に従い配置される．クエリは優位属性に対応するハブを進む．各ノードは他のハブ内のノードへのリンクを保持しているため，優位属性に対応するハブに1ステップで送信することができる．その後，Chordリングの探索アルゴリズムでクエリは転送される．支配属性での探索結果が多い場合，クエリの性能は著しく低下してしまうため，優位属性を賢く選択することは，非常に重要である．

Mercuryの欠点は索引付ける属性の数が大きいとき，データを挿入，離脱するコストが高いことである．その理由は，全てのハブに対して挿入，離脱を行う必要があるからである．


\subsubsection{SSP}
SSPはP2Pネットワーク上でスカイラインクエリを支持するための方法である．基本的な考え方は，多次元空間を各ノードが担当する多次元領域に分割することである．担当領域の場所を\textbf{z-curve}の順に並べることで，一次元インデックスを支持できる．ノードはBATON内に配置される．ルーティングのために，各ノードはBATONのリンクの情報に加えて，以下の担当範囲の情報を保持する必要がある．
\begin{itemize}
  \item\textbf{領域番号} (\textit{region number}): 領域のz-curve順での位置の識別子を示す．
  \item\textbf{データ範囲} (\textit{data range}): 領域が含んでいる値の範囲を示す．
  \item\textbf{分割履歴} (\textit{split history}): 領域が生成された時点からの分割を表す，値と次元の組みのリストを示す．
  \item\textbf{次の分割次元} (\textit{next partition dimension}): 領域が分割されるときに、次に分割される次元を示す．
\end{itemize}
SSPでのスカイラインクエリは以下の4ステップで行われる．
\begin{itemize}
  \item[-]最初に，システムはノード内のスカイラインの計算が必ず最終的なスカイラインに含まれることを保証したノードを探索する．このノードは，他の全ての点よりも優位な点を含むノードを探索することで発見しうる．
  このノードを\textbf{STARTER}ノードという.
  \item[-]STARTERノードに到達すると，ノード内のスカイライン結果を計算し，最も大きい支配領域を持つ点$p_{md}$を選ぶ．探索空間から$p_{md}$の支配領域は除かれ，スカイライン探索空間がその時決定される．
  \item[-]その後，STARTERノードは探索範囲を含んでいるノードにクエリを送信する．各ノードはノード内のスカイラインを計算し，クエリを生成したノードに結果を送信する．
  \item[-]最後に，クエリを生成したノードは，受信したローカルなスカイラインの結果から全体のスカイラインを計算する．
\end{itemize}
SPPの欠点は，クエリの処理スピードがSTARTERノードに大きく影響されることである．STARTERノードに到達できない場合や，$p_{md}$が存在しない場合，クエリの処理スピードは減少してしまう．

\subsection{\textbf{高次元インデックス} (\textit{high-dimensional indexing})}
ファイルの記述だけで完全にファイルの内容を表すことは不可能である．そのため，細かい粒度で探索可能なコンテンツベース探索が望まれている．コンテンツベース探索を支持する一般的な手法は，ファイルの特徴ベクトルを作成し，それらをインデックスに従い配置する方法である．しかし，特徴ベクトルの次元は非常に大きくなるため，従来の多次元インデックスでは効率が悪い．高次元空間データをインデックスに基づき配置するための新しい方法は，以下の3種類に大きく分類される．
\begin{itemize}
  \item\textbf{マッピングベースアプローチ} (\textit{mapping-based approach}): 高次元空間はインデックスの前に低次元空間にマッピングされる．複数次元クエリは，低次元でのクエリに変換されて実行される．多くのシステムは，\textbf{空間充填曲線} (\textit{Space Filling Curve, SFC}) を利用している．
  \item\textbf{距離ベースアプローチ} (\textit{distance-based approach}): \textbf{基準点} (\textit{reference points})と呼ばれる，事前に定められた点からの距離に基づいて，多次元オブジェクトは直接索引付けされる．インデックスの値は，オブジェクトから最も近い基準点への距離と，その基準点の値の合計で計算される． 
  \item\textbf{ハッシングベースアプローチ} (\textit{hashing-based approach}): インデックスのために，局所性鋭敏型ハッシュを用いる．クエリは，インデックスに対応するハッシュ値の周辺を探索する．この方法では常に正確な返答が得られるとは限らないが，結果のエラー率が事前に定義した値以下であることを保証する．
  \end{itemize}
 
一般的に，多次元インデックスを支持するため，P2Pシステムは集中型システムで研究された技術を採用している．しかし，それらの技術を，分散P2P環境に合うように適用させる必要が有る．例えば，\textbf{k近傍} (\textit{kNN})クエリの集中型システムアルゴリズムは，$k$個のオブジェクトが含まれるまで，徐々にクエリの範囲を広げていき，最も近い$k$個を選択する．P2Pシステムにこのアルゴリズムを直接適用すると，多くのメッセージが発生し，クエリのコストが高くなる．よって，k近傍クエリのアルゴリズムはP2Pシステムに合わせて修正する必要がある．

\subsubsection{\textbf{CISS}}
\textbf{CISS}は，高次元インデックスを支持するために，多次元空間を1次元空間にマッピングする\textbf{ヒルベルト空間充填曲線} (\textit{Hilbert Space Filling Curve})を利用し，1次元データはChordにインデックスされる．最初に，各次元の値をビットキーに変換し，多次元空間をビットキーの集合で表す．その後，ヒルベルト空間充填曲線を用いて，ビットキーの集合を一つのビットキーに変換する．最後にその一つのキーの値をChordにインデックスする．クエリは，多次元の値から1次元の値に変換されChordリング上を探索する．多次元空間の一つの領域は，1次元空間の複数の区間に変換されてしまうため，特に次元が大きいとき，クエリの効率は悪くなる．

\subsubsection{\textbf{ZNet}}
\textbf{ZNet}は，多次元空間を1次元空間にマッピングするためにz-curveを利用する．データ空間は四分木のような方法で再帰的に分割される．各部分空間には，z-curveでの位置と分割のレベルに対応した一意のアドレスが割り当てられる．各ノードは各部分空間とその空間内に位置するデータを担当する．ノードは担当する領域のアドレスの順にSkip Graphに並べられる．ノードがクエリを発行又は受信すると，探索範囲を含んでいる部分空間のアドレスを調べ，その部分空間を担当しているノードにクエリを転送する．空間の分割の情報が不足しており，アドレスが完全には知ることが不可能であるときも，接頭辞を知ることは可能である．この場合，探索範囲に近い隣接ノードにクエリを転送する．

\subsubsection{\textbf{M-Chord}}
M-Chordは，高次元空間での\textbf{類似検索} (\textit{similarity search})を支持する．M-Chordは以下の2段階で多次元インデックスを実現する．
\begin{enumerate}
 \item 高次元データを1次元データにマッピングするために，\textbf{iDistance}を利用する．iDistanceは，全体に知られた基準点を利用してデータ空間を分割し，データを最も近い基準点からの距離によってインデックスする．
 \item 1段階目で得られた1次元の値をChordリング上にインデックスする．
\end{enumerate}
iDistanceでは，データ空間を事前に分割の集合$S = \{P_{1},P_{2},...P_{n}l\}$に分ける必要がある．各分割$P_i$は基準点$O_i$と半径$r_i$によって表される．各$P_i(O_i,r_i)$が互いに重ならない区間[$i \cdot c, i \cdot c + r_i$]に相当するように定数$c$を選ぶ($keyO_i = i \cdot c$は$O_i$が対応する1次元の値)．データオブジェクト$D$がシステムに挿入されると，最初に，データオブジェクトから最も近い基準点$O_j$を調べ，$D$のインデックスの値を$j \cdot c + dist(D,O_j)$と計算する．そして，1次元インデックスの値でChordリングに挿入する．

$o$を中心，$r$を半径とするレンジクエリ$QR(o,r)$を行うとき，最初に検索範囲を含む分割を調べる．その後，検索範囲を含む各分割$P_i(O_i,r_i)$に対応する，1次元レンジクエリ$q[keyO_i + dist(O_i,o) − r,max(keyO_i + dist(O_i,o) + r,keyO_i + r_i)]$をChordリング上で行う．

$o$を中心，$k$を探索するオブジェクトの個数とする\textbf{k近傍} (\textit{kNN})クエリは以下の2段階で行う．
\begin{enumerate}
 \item 低コストな発見的手法で$o$から近い$k$個のオブジェクトを見つけ，それらのオブジェクトと$o$との距離の最大値$\delta$を求める．
 \item レンジクエリ$QR(o,\delta)$を行い，その結果の中から，$o$から近いk個を選ぶ．
\end{enumerate}

M-Chordの欠点として，オブジェクトを個々にインデックスする必要があるため，オブジェクトの個数が多いとき，インデックスのコストが高くなるという点が存在する．
\subsubsection{\textbf{SIMPEER}}
インデックスのコストが高くなることを避けるため，\textbf{SIMPEER}はインデックスの前にオブジェクトを要約し，その要約のみをインデックスする．SIMPEERは，以下の3つのレベルのインデックス構造を利用する，スーパピアベースのシステムである．
\begin{itemize}
  \item 最も低いレベルでは，各ピアは自身の共有オブジェクトをインデックスする．さらに，自身の共有オブジェクトをクラスタとして，その要約を作成し，自身を担当しているスーパピアに送信する．
  \item スーパピアのレベルでは，担当しているピアから送られてきたクラスタの要約をインデックスする．また，それらのクラスタの要約で\textbf{ハイパークラスタ}を作り，他のスーパピアに送信する
  \item 最も高いレベルでは，スーパピアは自身のハイパークラスタと他のスーパピアから受信したハイパークラスタのインデックスを作成する．
\end{itemize}
ピアはクエリを発行するとき，自身を担当しているスーパピアにクエリを送信する．スーパピアは，ローカルなクラスタの要約やハイパークラスタのインデックスに基づき，担当ピアや他のスーパピアにクエリを転送する．

クラスタの要約をインデックスするために，SIMPEERはiDistanceと同じように，全体に知られた基準点を利用しデータ空間を分割する．最初にクラスタの中心に最も近い基準点$O_i$を持つ分割$P_i$を調べ，クラスタの最も遠い点を基準点$O_i$に基づいて，1次元のインデックスの値に変換する．レンジクエリは，探索範囲と重なっている部分空間を含む各分割$P_i$に対し，クエリの範囲のうち基準点$O_i$に最も近い点から，分割$P_i$の境界までを探索することで実行する．

SIMPEERには2つの欠点が存在する．1つは，基準点とクエリ範囲の距離が近いとき，クエリ範囲の大きさに関わらず，広い範囲を探索する必要がある点である．もう1つは，分割はクラスタ全体を覆う必要があるため，探索空間が大きくなり，探索コストが高くなることである．


\subsubsection{\textbf{LSH Forest}}
\textbf{LSH Forest}は，$l$個の\textbf{LSH Tree}を含むインデックス構造である．このシステムは，インデックスのために局所性鋭敏型ハッシュの集合$\cal H$を使用する．オブジェクト$O$は$l$個のLSH Treeにインデックスされる．各LSH Treeで$O$には可変長$x$桁の識別子が割り当てられる．識別子は，$\cal H$から選んだ$h_1(),h_2(),...,h_x()$を利用して，$h_1(O),h_2(O),...,h_x(O)$と並べたものとなる．識別子の各桁がLSH Treeの根からのパスを表し，$Oを$示す葉の位置が決まる．
類似クエリを実行するには，クエリオブジェクトの識別子を同様に生成し，$l$個のLSH Treeで接頭辞が最長一致する葉をトップダウンに探す．それらの葉からボトムアップに木を走査しながら，到達したノードの子孫の葉に当たる類似のオブジェクトを集める．$M$個のオブジェクトを集めるまで走査を続け，$M$個の中から最もクエリオブジェクトに近いオブジェクトを返す．

\end{document}